# payhere_assignment
+ Python Backend (신입) 전형
+ 지원자 명 : 김영빈

<br/>
<br/>

## 과제 수행 정도 및 설명
+ 과제의 요구사항을 모두 구현하였습니다
+ 테스트케이스는 시간부족으로 일부만 작성하였습니다
+ MYSQL 5.7 버전의 RDS를 사용하고 있습니다. 따라서 메일에 함께 동봉한 secret_settings.py를 프로젝트 폴더의 최상위 경로에 두고 requirements.txt 파일을 통해 라이브러리를 설치한 후 실행하시면 바로 해당 payhere데이터베이스에 접속하실 수 있습니다.
+ 해당 데이터베이스에 마이그레이션은 적용해두었습니다.


<br/>
<br/>


## 모델
+ 유저, 레코드, 단축URL 총 세 개의 테이블이 존재합니다
+ 레코드 테이블은 유저테이블을 1:N관계로(유저가 1) 참조하고 있습니다.



<br/>
<br/>

## 유저 
커스텀 유저모델을 사용 
+ 장고의 기본 유저모델은 username을 기본필드로 사용하고 있고, 추후에 유저모델을 변경할 경우의 용이성을 고려하여  커스텀 유저모델을 사용하였습니다.

<br/>

회원가입
+ 회원가입에 성공할 경우 바로 로그인상태가 될 수 있도록, 회원가입에 성공하면 바로 jwt 토큰과 이메일을 반환하도록 하였습니다.
+ 비밀번호는 암호화되어 저장 DB에 저장되도록 설게하였습니다

<br/>
<br/>

## 인증

로그인
+ 로그인에 성공하면, 서버측에서 access_token과 refresh_token을 응답에 담아서 보냅니다
+ 또한 로그인에 성공한 유저의 email을 함께 담아서 응답합니다. 

<br/>

인증
+ 인증이 필요한 api를 호출할 경우, 프론트측에서 header에 access_token을 함께 보내어 인증을 진행합니다

<br/>

로그아웃
+ 프론트측에서 access_token과 refresh_token을 제거합니다.

<br/>
access_token 만료
+ 만약 access_token이 만료될 경우,클라이언트는 refresh_token을 제공하여 access_token을 재발급받을 수 있는 api를 호출합니다
+ 서버는 refresh_token이 유효하면 새 access_token을 새로 발급하여 응답합니다.


<br/>
<br/>

## 가계부
3-a / 3-d
+ REST API의 규칙을 준수하여 3-a(Create)와 3-d(List)는 동일한 url을 사용합니다
+ access_token을 기반으로 유저가 인증 되지 않으면 401 Unauthorized Error가 발생합니다
+ 3-d는 CBV의 queryset변수 설정을 통해, 인증된 유저가 작성한 기록만 불러오도록 하였습니다

<br/>

3-b / 3-c / 3-e
+ REST API의 규칙을 준수하여 3-b(Update)와 3-c(Delete) 그리고 3-e(Retrieve)는 동일한 url을 사용합니다
+ access_token을 통해 인증이 되지 않으면 401 Unauthorized Error가 발생합니다
+ 자신이 작성하지 않은 레코드에 접근할 경우 403 Forbidden Error가 발생합니다
+ 3-b는 Put과 Patch메서드 두가지를 모두 구현하였습니다. Patch메서드는 수정하고자 하는 필드만 수정할 수 있으며, Put메서드는 null값을 가질 수 없는 필드(해당 모델에서는 money필드)에 대한 값이 없으면 에러가 발생하도록 설계하였습니다.


<br/>

3-f
+ 가계부의 세부내역을 복제한다는 것은 결국 동일한 세부내역을 가진 기록을 하나 더 생성하는 것이라고 생각했습니다. 따라서 새로운 api를 만들기보다는 (3-a에서)이미 만든 record Create API를 활용하는 것이 유지&보수를 고려할 때 효율적이라고 판단했습니다.
+ 또한 고객입장에서 기록의 세부정보 외에도 복사하고 싶은 필드가 있을 수도 있고, 새로 작성하고 싶은 필드가 있을 수도 있다고 생각했습니다
+ 따라서 새롭게 생성된 객체가 기본적으로는 복사하려는 객체와 동일한 필드값을 갖도록 하되, body데이터를 통해 특정 필드와 그 값을 보낼 경우 보내진 필드는 보내진 값을 갖도록 설계하였습니다.
+ 복사하려는 record의 id 값을 copy_record_id라는 이름의 query_parameter로 받습니다
+ copy_record_id로 받은 값과 일치하는 id를 가진 record 객체를 찾습니다. 이 과정에서 일치하는 id없다면 404에러를, id가 일치하는 record객체가 있더라도 작성자와 요청을 보낸 유저가 불일치하다면 403에러를 발생시키도록 하였습니다.
+ 복사된 데이터에 body데이터로 받은 필드가 있다면 해당 필드를 업데이트 시켜 최종 데이터를 만듭니다. 만들어진 데이터를 기반으로 새로운 레코드 객체를 생성하여 저장하도록 하였습니다.

<br/>

3-g
+ 단축url은 외부api를 사용하는 방식을 고민했으나, 의존성을 낮추고 싶어 내부적으로 구현하였습니다.
+ 특정 Record 리소스에 대한 url을 통해 ShortCutURLView를 post메서드로 호출함으로써 해당 Record에 대한 단축 URL을 만들 수 있습니다.
+ 이때, 고객은 특정 레코드의 원하는 필드만 공유하고 싶을 것이므로, 고객이 원하는 필드를 쿼리파라미터로 받을 수 있도록 설계하였습니다. 쿼리파라미터를 보내지 않는다면, 해당 레코드의 모든 정보에 조회할 수 있는 단축 URL을 만듭니다. 이 과정에서 요청을 보낸 레코드가 존재하지 않는다면 404 에러를, 요청을 보낸 유저와 레코드의 작성자가 일치하지 않는다면 403 에러를 발생시키도록 하였습니다.
+ 또한 만들어지는 shortURL이 며칠간 유효할지에 대한 값을 쿼리파라미터로 받을 수 있도록 설계하였습니다. 쿼리파라미터로 받은 유효일자에 따라 해당 short_url의 유효기간이 정해집니다. 
+ shortURL이 만들어지면, 만들어진 short_url과 기존의 original_url, 그리고 short_url을 만들기 위한 url_string과 유효기간을 하나의 객체로 저장하고, 만들어진 short_url을 반환합니다.
+ 고객이 short_url로 접근하면, url에 입력된 short_url을 기반으로 original_url을 찾아냅니다. 이 과정에서 해당 shortURL의 유효기간이 지났다면 400에러가 발생하도록 설계하였습니다.
+ 찾아낸 original_url로 redirect가 수행되어 ShortCutURLView를 get메서드로 호출하도록 합니다. 호출된 ShortCutURLView는 path_parameter와 query_parameter를 통해 어떤 레코드의 어떤 필드에 대한 정보가 필요한지를 알게되고 이를 응답합니다.
