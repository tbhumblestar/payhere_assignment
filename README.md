# payhere_assignment
+ Python Backend (신입) 전형
+ 지원자 명 : 김영빈

<br/>
<br/>

## 과제 수행 정도 및 설명
+ 과제의 요구사항을 모두 구현하였습니다
+ 테스트케이스는 시간부족으로 일부만 작성하였습니다
+ MYSQL 5.7 버전의 RDS를 사용하고 있습니다. 메일에 함께 동봉한 secret_settings.py를 프로젝트 폴더의 최상위 경로에 두고 requirements.txt 파일을 통해 라이브러리를 설치한 후 실행하시면 바로 해당 payhere데이터베이스에 접속하실 수 있습니다.
+ 해당 데이터베이스에 마이그레이션은 적용해두었습니다.


<br/>
<br/>


## 모델
모델들간의 관계(1:~)



<br/>
<br/>

## 유저 
커스텀 유저모델을 사용 
+ 장고의 기본 유저모델은 username을 기본필드로 사용하고 있고, 추후에 유저모델을 변경할 경우의 용이성을 고려하여  커스텀 유저모델을 사용하였습니다.

<br/>

회원가입
+ 회원가입에 성공할 경우 바로 로그인상태가 될 수 있도록, 회원가입에 성공하면 바로 jwt 토큰과 이메일을 반환하도록 하였습니다.
+ 비밀번호는 암호화되어 저장 DB에 저장되도록 설게하였습니다

<br/>
<br/>

## 인증

로그인
+ 로그인에 성공하면, 서버측에서 access_token과 refresh_token을 응답에 담아서 보냅니다
+ 또한 로그인에 성공한 유저의 email을 함께 담아서 응답합니다. 

<br/>

인증
+ 인증이 필요한 api를 호출할 경우, 프론트측에서 header에 access_token을 함께 보내어 인증을 진행합니다

<br/>

로그아웃
+ 프론트측에서 access_token과 refresh_token을 제거합니다.

<br/>
access_token 만료
+ 만약 access_token이 만료될 경우,클라이언트는 refresh_token을 제공하여 access_token을 재발급받을 수 있는 api를 호출합니다
+ 서버는 refresh_token이 유효하면 새 access_token을 새로 발급하여 응답합니다.


<br/>
<br/>

## 가계부
3-a / 3-d
+ REST API의 규칙을 준수하여 3-a(Create)와 3-d(List)는 동일한 url을 사용합니다
+ access_token을 기반으로 유저가 인증 되지 않으면 401 Unauthorized Error가 발생합니다
+ 3-d는 CBV의 queryset변수 설정을 통해, 인증된 유저가 작성한 기록만 불러오도록 하였습니다

<br/>

3-b / 3-c / 3-e
+ REST API의 규칙을 준수하여 3-b(Update)와 3-c(Delete) 그리고 3-e(Retrieve)는 동일한 url을 사용합니다
+ access_token을 통해 인증이 되지 않으면 401 Unauthorized Error가 발생합니다
+ 자신이 작성하지 않은 레코드에 접근할 경우 403 Forbidden Error가 발생합니다
+ 3-b는 Put과 Patch메서드 두가지를 모두 구현하였습니다. Patch메서드는 수정하고자 하는 필드만 수정할 수 있으며, Put메서드는 null값을 가질 수 없는 필드(해당 모델에서는 money필드)에 대한 값이 없으면 에러가 발생하도록 설계하였습니다.


<br/>

3-f
+ 가계부의 세부내역을 복제한다는 것은 결국 동일한 세부내역을 가진 기록을 하나 더 생성하는 것이라고 생각했습니다. 따라서 새로운 api를 만들기보다는 (3-a에서)이미 만든 record Create API를 활용하는 것이 유지&보수를 고려할 때 효율적이라고 판단했습니다.
+ 또한 고객입장에서 기록의 세부정보 외에도 복사하고 싶은 필드가 있을 수도 있고, 새로 작성하고 싶은 필드가 있을 수도 있다고 생각했습니다
+ 따라서 새롭게 생성된 객체가 기본적으로는 복사하려는 객체와 동일한 필드값을 갖도록 하되, body데이터를 통해 특정 필드와 그 값을 보낼 경우 보내진 필드는 보내진 값을 갖도록 설계하였습니다.
+ 복사하려는 record의 id 값을 copy_record_id라는 이름의 query_parameter로 받습니다
+ copy_record_id로 받은 값과 일치하는 id를 가진 record 객체를 찾습니다. 이 과정에서 일치하는 id없다면 404에러를, id가 일치하는 record객체가 있더라도 작성자와 요청을 보낸 유저가 불일치하다면 403에러를 발생시키도록 하였습니다.
+ 복사된 데이터에 body데이터로 받은 필드가 있다면 해당 필드를 업데이트 시켜 최종 데이터를 만듭니다. 만들어진 데이터를 기반으로 새로운 레코드 객체를 생성하여 저장하도록 하였습니다.

<br/>

3-g
+ 고객은 원하는 레코드들의 원하는 필드만 제시하고 싶을 것이므로, 고객이 원하는 필드를 쿼리파라미터로 받을 수 있도록 설계하였습니다
+ 단축url은 외부api를 사용하는 방식을 고민했으나, 의존성을 낮추고 싶어 내부적으로 구현하였습니다
+ 고객이 원하는 유효시간을 설정할 수 있도록 하였습니다.
